Object subclass: #MyStack	instanceVariableNames: 'a_content a_index a_capacity'	classVariableNames: 'DEFAULT_CAPACITY'	poolDictionaries: ''	category: 'HMIN305-MyStack'!!MyStack methodsFor: 'initialization' stamp: 'harkame 9/21/2018 13:47'!printOn: p_stream	p_stream nextPutAll: 'An stack of '.	a_capacity printOn: p_stream.	p_stream nextPutAll: ', Index : '.	a_index printOn: p_stream.	p_stream nextPutAll: ', Content :'.		a_index > 0		ifTrue:		[			1 to: a_index do:			[				:t_index | (a_content at: t_index) printOn: p_stream cr.			]		]	! !!MyStack methodsFor: 'initialization' stamp: 'harkame 9/21/2018 14:12'!initialize: p_capacity	a_index := 0.	a_capacity := p_capacity.	a_content := Array new: a_capacity.! !!MyStack methodsFor: 'testing' stamp: 'harkame 9/21/2018 13:25'!push: p_objectToPush	a_index > a_capacity		ifTrue: [ ^ self ].			a_index := a_index + 1.	a_content at: a_index put: p_objectToPush.! !!MyStack methodsFor: 'testing' stamp: 'harkame 9/21/2018 13:17'!pop	a_index > 0		ifTrue:		[			a_index := a_index - 1.		]! !!MyStack methodsFor: 'testing' stamp: 'harkame 9/21/2018 13:10'!isFull	^a_index = a_capacity.! !!MyStack methodsFor: 'testing' stamp: 'harkame 9/21/2018 13:17'!top	^a_content at: a_index.! !!MyStack methodsFor: 'testing' stamp: 'harkame 9/21/2018 13:09'!isEmpty	^a_index = 0.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyStack class	instanceVariableNames: ''!!MyStack class methodsFor: 'instance creation' stamp: 'harkame 9/21/2018 14:24'!initialize	DEFAULT_CAPACITY := 5.! !!MyStack class methodsFor: 'instance creation' stamp: 'harkame 9/21/2018 14:21'!new: p_capacity	| r_myStack |		r_myStack := super new.	r_myStack initialize: p_capacity.		^r_myStack.! !!MyStack class methodsFor: 'instance creation' stamp: 'harkame 9/21/2018 14:21'!new	| r_myStack |		r_myStack := super new.	r_myStack initialize: DEFAULT_CAPACITY.		^r_myStack.! !!MyStack class methodsFor: 'instance creation' stamp: 'harkame 9/21/2018 14:30'!example  |myStack|  myStack := MyStack new: 9.  myStack printOn: Transcript.  myStack push: 9.  myStack push: 42.  myStack printOn: Transcript.  myStack pop.  myStack printOn: Transcript.! !MyStack initialize!Object subclass: #Pile	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'tailleDefaut'	poolDictionaries: ''	category: 'HMIN305-Pile'!!Pile commentStamp: 'cd 3/8/2017 10:34' prior: 0!Implantation d'une pile en utilisant une collection ordonnée.Internal Representation and Key Implementation Points.    Instance Variables	contenu:		<Collection>	index:		<Integer>	taille:		<Integer>    Implementation Points!!Pile methodsFor: 'initialization' stamp: 'cd 3/30/2018 09:29'!initialize: taille	"initialise les attribus d'une pile nouvellement créée"	"la pile est vide quand index = 0"	index := 0.	"la pile est pleine quand index = capacite"	capacite := taille.	"le contenu est représenté par un tableau"	contenu := Array new: capacite.		"self assert: (self isEmpty)."	! !!Pile methodsFor: 'enumerating' stamp: 'cd 4/15/2016 10:37'!do: aBlock	"un itérateur pour la classe Pile"	buffer do: aBlock.					! !!Pile methodsFor: 'printing' stamp: 'cd 3/15/2017 12:27'!printOn: aStream	"Cette méthode est appelée par la méthode printString qui fabrique une représentation du    receveur sous forme de chaîne.	 PrintString est elle-même appelée par les outils de l'environnement, par exemple par la    méthode printIt du Playground."		aStream nextPutAll: 'une Pile, de taille: '.	capacite printOn: aStream.	aStream nextPutAll: ' contenant: '.	index printOn: aStream.	aStream nextPutAll: ' objets : ('.	contenu do: [ :each | each printOn: aStream. aStream space ].	aStream nextPut: $).! !!Pile methodsFor: 'métier' stamp: 'cd 3/30/2018 10:18'!push: anObject	"met anObject dans contenu au bon index si la pile n'est pas pleine"	self isFull		ifFalse: ["les tableaux commencent à l'index 1"					index := index + 1.					contenu at: index put: anObject]		ifTrue: [ self error: 'Impossible empiler sur une pile pleine' ]! !!Pile methodsFor: 'métier' stamp: 'cd 3/30/2018 10:33'!isFull	^(index = capacite)! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:54'!pop	"dépile et rend le sommet de pile si la pile n'est pas vide"	| retour |	self isEmpty		ifFalse: [			retour := contenu at: index.			index := index - 1.			^retour]		ifTrue: [ self error: 'Pile vide, Impossible de dépiler' ]! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 13:06'!size	"donne le nombre d'éléments empilés"	^index		"^contenu count: [ :each | each isNotNil ]"	! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:53'!isEmpty	^index = 0! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:55'!top	"rend le sommet de pile si la pile n'est pas vide, sans dépiler"	self isEmpty		ifFalse: [ ^contenu at: index]		ifTrue: [ self error: 'Rien au sommet d''une pile vide' ]! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 13:22'!grow	| nb oldc |	nb := self size.	oldc := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	0 to: nb do: [ :i |  self push: (oldc at: i)]	! !!Pile methodsFor: 'métier' stamp: 'cd 3/28/2018 13:01'!capacity	^capacite	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pile class	instanceVariableNames: ''!!Pile class methodsFor: 'examples' stamp: 'cd 3/28/2018 14:39'!example	"self example" 	"Un exemple de la façon dont on peut utiliser une pile dans un programme"	| p |	p := Pile new.	p push: 33.	p push: 'une chaine'.	p push: 2 @ 3.	p push: 5 factorial.	p push: p isFull.	p pop.	p push: p size.	^p! !!Pile class methodsFor: 'instance creation' stamp: 'cd 3/28/2018 12:56'!initialize	tailleDefaut := 5.! !!Pile class methodsFor: 'instance creation' stamp: 'cd 3/28/2018 12:34'!new	"Ceci est une méthode de class.	Que vaut 'self'? La classe à laquelle a été envoyé le message ...	donc la class Pile ou une de ses sous-classes"		^super new  initialize: tailleDefaut	! !Pile subclass: #PileTypee	instanceVariableNames: 'typeElements'	classVariableNames: ''	poolDictionaries: ''	category: 'HMIN305-Pile'!!PileTypee commentStamp: 'cd 3/28/2018 12:58' prior: 0!Une pile où le type des éléments est fixé a priori.!!PileTypee methodsFor: 'initialization' stamp: 'cd 3/28/2018 18:20'!initialize: unType	super initialize.	typeElements := unType.! !!PileTypee methodsFor: 'initialization' stamp: 'cd 3/28/2018 13:29'!de: T	super initialize.	typeElements := T.! !!PileTypee methodsFor: 'métier' stamp: 'cd 3/24/2018 20:00'!push: anObject	(anObject isKindOf: typeElements)		ifTrue: [ super push: anObject ]		ifFalse: [ self error: 			'Impossible d''empiler ' , 			anObject asString, 			' dans une pile typee de ' , 			typeElements asString]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PileTypee class	instanceVariableNames: ''!!PileTypee class methodsFor: 'examples' stamp: 'cd 3/28/2018 18:10'!example	"self example"	"Un exemple de la façon dont on peut utiliser une pile typée dans un programme"	| p |	p := PileTypee de:  Number.	p push: 33.	p push: 2.5.	p push: 5 factorial.	p pop.	[ p push: 'hello'] on: Error do: [ Transcript show: 'ne pas faire' ].	^p! !!PileTypee class methodsFor: 'instanceCreation' stamp: 'cd 3/28/2018 18:13'!de: type	^super new de: type! !TestCase subclass: #TestPile	instanceVariableNames: 'standard pleine vide'	classVariableNames: ''	poolDictionaries: ''	category: 'HMIN305-Pile'!!TestPile methodsFor: 'tests' stamp: 'cd 3/8/2017 11:48'!testPush	standard push: 33.	self assert: (standard isEmpty not).	self assert: (standard top = 33).! !!TestPile methodsFor: 'tests' stamp: 'cd 3/28/2018 17:35'!testPush2	standard push: 22.	self assert: standard top equals: 22.	! !!TestPile methodsFor: 'tests' stamp: 'cd 3/28/2018 17:34'!testFull	self assert: pleine isFull.! !!TestPile methodsFor: 'tests' stamp: 'cd 3/8/2017 11:44'!testPleine	self assert: pleine isFull	! !!TestPile methodsFor: 'tests' stamp: 'cd 3/15/2017 10:29'!testPop	| current r |	current := standard top.	standard push: #test.	r := standard pop.	self assert: (standard isFull not).	self assert: (r == #test).	self assert: (standard top == current).! !!TestPile methodsFor: 'tests' stamp: 'cd 3/28/2018 17:33'!testEmpty	self assert: vide isEmpty.! !!TestPile methodsFor: 'initialization' stamp: 'cd 3/28/2018 17:32'!setUp	Transcript show: 'execution de setUp test Pile'.	"une pile vide"	vide := Pile new initialize: 3.		"une pile standard ni vide ni pleine"	standard := Pile new initialize: 4.	standard push: 1.		"une pile pleine"	pleine := Pile new initialize: 2.	pleine push: 1.	pleine push: 2.! !Pile initialize!Object subclass: #MyList	instanceVariableNames: 'a_element a_next'	classVariableNames: ''	poolDictionaries: ''	category: 'HMIN305-MyList'!!MyList methodsFor: 'printing' stamp: 'harkame 9/28/2018 11:06'!printOn: p_stream	a_element printOn: p_stream. 	a_next isEmpty	ifTrue: 	[	]	ifFalse:	[		a_next printOn: p_stream.	]! !!MyList methodsFor: 'adding' stamp: 'harkame 9/28/2018 11:05'!addElement: p_element	a_next isEmpty	ifTrue: 	[ 		a_next := MyList new.		a_next initialize: p_element.	]	ifFalse:	[		a_next addElement: p_element. 	]! !!MyList methodsFor: 'initialization' stamp: 'harkame 9/28/2018 10:32'!initialize: p_element	a_element := p_element.	a_next := nil.! !!MyList methodsFor: 'enumerating' stamp: 'harkame 9/28/2018 11:22'!do: aBlock	| next |	 next:= a_next.	[next == nil] whileFalse:		[aBlock value: next value.		 next := a_next]! !!MyList methodsFor: 'testing' stamp: 'harkame 9/28/2018 10:54'!isEmpty	^False.! !Object subclass: #MyInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HMIN305-inspector'!!MyInspector methodsFor: 'running' stamp: 'harkame 9/28/2018 12:17'!inspect: object	object class allClassVarNames printOn: Transcript.! !Object subclass: #Counter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'HMIN305-Counter'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Counter class	instanceVariableNames: ''!!Counter class methodsFor: 'operations' stamp: 'harkame 9/28/2018 10:36'!create	| x |	x := 0.	^ [ x := x + 1 ]! !