SystemOrganization addCategory: #ObjVLispSkeleton!SystemOrganization addCategory: 'ObjVLispSkeleton-AdvancedTests'!SystemOrganization addCategory: 'ObjVLispSkeleton-Inspector'!BasicIndexedEyeElement variableSubclass: #StrictlyOrderedEyeElement	instanceVariableNames: 'orderedStructure'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVLispSkeleton-Inspector'!!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!orderedStructure		^ orderedStructure! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!orderedStructure: anObject		orderedStructure := anObject! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!value	^ self host basicAt: (self orderedStructure indexOf: index)! !EyeCollectionInspector variableSubclass: #ObjClassInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVLispSkeleton-Inspector'!!ObjClassInspector commentStamp: 'StephaneDucasse 11/16/2014 23:11' prior: 0!I'm a simple inspector that can inspect fixed structured Obj class."creating class by hand"| coloredPointClass |coloredPointClass := Obj new: 6.coloredPointClass at: coloredPointClass offsetForName put: #ObjColoredPoint.coloredPointClass at: coloredPointClass offsetForClass put: #ObjClass.coloredPointClass at: coloredPointClass offsetForIVs put: #( #class #x #y #color).coloredPointClass at: coloredPointClass offsetForSuperclass put: #ObjPoint.coloredPointClass at: coloredPointClass offsetForMethodDict	put: (IdentityDictionary new).coloredPointClass.ObjClassInspector basicInspect: coloredPointClass.!!ObjClassInspector methodsFor: 'list' stamp: 'StephaneDucasse 11/16/2014 23:10'!addVariableFields: elements		| classStructure |	classStructure := Obj classInstanceVariables.	classStructure do: [ :key |		elements add: (StrictlyOrderedEyeElement new 								orderedStructure: classStructure;								host: self object;								index: key; 								yourself)]! !Array variableSubclass: #ObjV	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVLispSkeleton'!ObjV class	instanceVariableNames: 'definedObjClasses'!!ObjV commentStamp: 'StephaneDucasse 12/6/2017 09:57' prior: 0!This is skeleton.... a class with missing parts that you should fill up.more information at http://books.pharo.org!ObjV class	instanceVariableNames: 'definedObjClasses'!!ObjV class methodsFor: 'bootstrap objMessage' stamp: 'StephaneDucasse 12/6/2017 09:52'!addMessagesForErrorHandling	"pre condition message has been created (and declared)"	"self addMessagesForErrorHandling"	| objMessage |	objMessage := self ObjMessage.	objMessage 		addUnaryMethod: #receiver 		withBody: 'objself valueOfInstanceVariable: #receiver'.	objMessage 		addUnaryMethod: #receiver2 		withBody: 'objself send: #getIV withArguments: #(#receiver)'.	objMessage 		addUnaryMethod: #selector 		withBody: 'objself send: #getIV withArguments: #(#selector)'.			objMessage 		addUnaryMethod: #arguments 		withBody: 'objself send: #getIV withArguments: #(#arguments)'.		objMessage 		addMethod: #setReceiver		args: 'receiver'		withBody:' objself send: #setIV withArguments: (Array with: #receiver with: receiver)'.			objMessage 		addMethod: #setSelector		args: 'selector'		withBody:' objself send: #setIV withArguments: (Array with: #selector with: selector)'.	objMessage 		addMethod: #setArguments		args: 'arguments'		withBody:' objself send: #setIV withArguments: (Array with: #arguments with: arguments)'.							^ objMessage ! !!ObjV class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 12/6/2017 09:52'!bootstrap	"self bootstrap"		self initialize.	self manuallyCreateObjClass.	self createObjObject.	self createObjClass.! !!ObjV class methodsFor: 'meta data' stamp: 'StephaneDucasse 12/6/2017 09:52'!classInstanceVariables	^ #(#class #name #superclass #iv #keywords #methodDict)! !!ObjV class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 12/6/2017 09:52'!createObjClass	"self bootstrap"	| objClass |	objClass := self objClassStructure.	self defineAllocateMethodIn: objClass.	self defineNewMethodIn: objClass.	self defineInitializeMethodIn: objClass.	objClass 		addUnaryMethod: #isMetaclass		withBody: 'objself objIVs includes: #superclass'.		"an object is a class if is class is a metaclass. cool"		objClass 		addUnaryMethod: #isClass		withBody: 'objself objClass send: #isMetaclass withArguments:#()'.	^objClass! !!ObjV class methodsFor: 'bootstrap objObject' stamp: 'StephaneDucasse 12/6/2017 09:52'!createObjObject	| objObject |	objObject := self objObjectStructure.	objObject addUnaryMethod: #class withBody: 'objself objClass'.	objObject addUnaryMethod: #isClass withBody: 'false'.	objObject addUnaryMethod: #isMetaclass withBody: 'false'. 	objObject 		addMethod: #error		args: 'arrayOfArguments'		withBody: 'Transcript show: ''error '', arrayOfArguments first.  ''error '', arrayOfArguments first'.	"some meta facilities"	objObject 		addMethod: #getIV		args: 'iv'		withBody: 'objself valueOfInstanceVariable: iv'.	objObject 		addMethod: #setIV		args: 'iv val'		withBody: 			' objself at: (objself offsetFromObjectOfInstanceVariable: iv) put: val'.	objObject 		addMethod: #initialize		args: 'initargs'		withBody: 'objself  initializeUsing: initargs'.	^objObject! !!ObjV class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 12/6/2017 09:52'!declareClass: anObjClass 	"To declare an ObjClass in the class repository"	| nameC |	nameC := anObjClass objName.	nameC isNil		ifFalse: [definedObjClasses at: nameC put: anObjClass]		ifTrue: [self error: 'The class does not have a name']! !!ObjV class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 12/6/2017 09:52'!defineAllocateMethodIn: class 	"The allocated obj method simply invokes the primitive allocateAnInstance."		class 		addUnaryMethod: #allocate 		withBody: 'objself allocateAnInstance'! !!ObjV class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 12/6/2017 09:52'!defineInitializeMethodIn: objClass 	objClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'objself super: #initialize withArguments: {initArray} from: superClassOfClassDefiningTheMethod.			objself objIVs: (objself							computeNewIVFrom: (Obj giveClassNamed: objself objSuperclassId) objIVs							with: objself objIVs).			objself computeAndSetKeywords.			objself objMethodDict: IdentityDictionary new.			Obj declareClass: objself.			objself'! !!ObjV class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 12/6/2017 09:52'!defineManualInitializeMethodIn: class 	class 		addMethod: #initialize		args: 'initArray'		withBody: 				'| objsuperclass |			objself initializeUsing: initArray.	"Initialize a class as an object. In the bootstrapped system will be done via super"			objsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].			objsuperclass isNil				ifFalse: 					[objself						objIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]				ifTrue: 					[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].			objself				objKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).			objself objMethodDict: (IdentityDictionary new: 3).			Obj declareClass: objself.			objself'! !!ObjV class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 12/6/2017 09:52'!defineNewMethodIn: class 	class 		addMethod: #new		args: 'initArray'		withBody: 			'(objself send: #allocate withArguments: #()) send: #initialize withArguments: { initArray } '.! !!ObjV class methodsFor: 'tricks' stamp: 'StephaneDucasse 12/6/2017 09:52'!doesNotUnderstand: aMessage	"debugging >>>  default shiftDown ifTrue:[ self halt ]."	"Sensor shiftPressed ifTrue:[ self halt ]."		^ definedObjClasses at: aMessage selector! !!ObjV class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 12/6/2017 09:52'!giveClassNamed: aSymbol 	"Return the class defined in the class repository with the name aSymbol"	^ self giveClassNamed: aSymbol ifAbsent: [self error: ('The class ' , aSymbol printString , ' is not defined')]! !!ObjV class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 12/6/2017 09:52'!giveClassNamed: aSymbol ifAbsent: aBlock	^ definedObjClasses at: aSymbol ifAbsent: aBlock! !!ObjV class methodsFor: 'initialize' stamp: 'StephaneDucasse 12/6/2017 09:52'!initialize	"self initialize"	 	definedObjClasses := IdentityDictionary new.	definedObjClasses at: #ObjClass put: nil.	definedObjClasses at: #ObjObject put: nil.	definedObjClasses at: #ObjMessage put: nil.! !ObjV initialize!!ObjV class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 12/6/2017 09:52'!manualObjClassStructure	| class |	class := Obj new: 6.	class objClassId: #ObjClass.	class objName: #ObjClass.	class objIVs: self classInstanceVariables.	class objKeywords: #(#name: #superclass: #iv: #keywords: #methodDict:).	class objSuperclassId: #ObjObject.	class objMethodDict: (IdentityDictionary new: 3).	^ class! !!ObjV class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 12/6/2017 09:52'!manuallyCreateObjClass	"self manuallyCreateObjClass"	| class |	class := self manualObjClassStructure.	Obj declareClass: class.	self defineManualInitializeMethodIn: class.	self defineNewMethodIn: class.	self defineAllocateMethodIn: class.	^class! !!ObjV class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 12/6/2017 09:52'!objClassStructure	^(Obj giveClassNamed: #ObjClass) send: #new		withArguments: #(#(#name: #ObjClass #iv: #(#name #superclass #iv #keywords #methodDict) #superclass: #ObjObject))! !!ObjV class methodsFor: 'bootstrap objMessage' stamp: 'StephaneDucasse 12/6/2017 09:52'!objClassStructureMessage	^ Obj ObjClass 		send: #new		withArguments: #(#(#name: #ObjMessage #iv: #(#receiver #selector #arguments) #superclass: #ObjObject))! !!ObjV class methodsFor: 'bootstrap objObject' stamp: 'StephaneDucasse 12/6/2017 09:52'!objObjectStructure	^(Obj giveClassNamed: #ObjClass) 		send: #new		withArguments: #(#(#name: #ObjObject #iv: #(#class)))! !!ObjV class methodsFor: 'skeleton metadata' stamp: 'StephaneDucasse 12/6/2017 09:52'!selectorToSkeletonize	^ #(#(objIVs objIVs: objKeywords objKeywords: objMethodDict objMethodDict: objName objName: objSuperclassId objSuperclassId: objClass objClassId objClassId: allocateAnInstance offsetFromClassOfInstanceVariable: offsetFromObjectOfInstanceVariable: valueOfInstanceVariable: send:withArguments: super:withArguments:from: lookup: bodyOfMethod:))! !!ObjV methodsFor: 'method management' stamp: 'StephaneDucasse 12/6/2017 09:52'!addMethod: aSelector args: aString withBody: aStringBlock 	"Define a method with selector <aSelector> , having a string representing the arguments (ie 'aNumber aStream') 	and a string representing the method body in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  objMethodDict at: aSelector put: (self methodWithHeader: aString andBody: aStringBlock).	^self! !!ObjV methodsFor: 'method management' stamp: 'StephaneDucasse 12/6/2017 09:52'!addUnaryMethod: aSelector withBody: aStringBlock 	"Define a unary method with selector <aSelector> and a body <aaStringBlock> in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  addMethod: aSelector args: '' withBody: aStringBlock! !!ObjV methodsFor: 'instance allocation' stamp: 'StephaneDucasse 12/6/2017 09:52'!allocateAnInstance	"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "	^ self! !!ObjV methodsFor: 'message passing' stamp: 'StephaneDucasse 12/6/2017 09:52'!basicSend: selector withArguments: arguments from: aClass	"Execute the method found starting from aClass and whose name is selector."	"The core of the sending a message, reused for both a normal send or a super one."		| methodOrNil |	methodOrNil := aClass lookup: selector.	^ methodOrNil 		ifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ] 		ifNil: [ self sendError: selector withArgs: arguments ] ! !!ObjV methodsFor: 'method management' stamp: 'StephaneDucasse 12/6/2017 09:52'!blockArgsFrom: aCol	"self basicNew blockArgsFrom: ' abc def ghi '"			| col st |	col := aCol findTokens: Character space.	col := col copyWithout: ''.	st := ''.	col do: [ :each | st := st , ':', each ] separatedBy: [st := st, ' '].	^ st! !!ObjV methodsFor: 'method management' stamp: 'StephaneDucasse 12/6/2017 09:52'!bodyOfMethod: aSelector	"Return the method associated with the selector <aSelector> in the receiver.	Return nil if the selector is not defined.  self is an objClass"	^ self! !!ObjV methodsFor: 'debugging' stamp: 'StephaneDucasse 12/6/2017 09:52'!classDebug	"(self giveClassNamed: #ObjClass) classDebug"	"(self giveClassNamed: #ObjSet) classDebug"	ObjClassInspector basicInspect: self! !!ObjV methodsFor: 'keyword management' stamp: 'StephaneDucasse 12/6/2017 09:52'!computeAndSetKeywords	"Compute the keywords of a given class.  As the class of an object should not be changed.	 the keywords should note contain the keyword class. self is anObjClass"	self objKeywords: (self generateKeywords: (self objIVs copyWithout: #class))! !!ObjV methodsFor: 'iv inheritance' stamp: 'StephaneDucasse 12/6/2017 09:52'!computeNewIVFrom: superIVOrdCol with: localIVOrdCol	"Returns an ordered collection that is the union without duplicate of ivOfSuper and ivOrderedCollection.	Important the order of the instance variable is conserved"	| ivs |	^superIVOrdCol isNil 		ifTrue: [localIVOrdCol]		ifFalse: 			[ivs := superIVOrdCol asOrderedCollection copy.			localIVOrdCol do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!ObjV methodsFor: 'iv inheritance' stamp: 'StephaneDucasse 12/6/2017 09:52'!computeNewIVFromClass: anObjClass with: ivOrderedCollection 	"Obj computeNewIVFromClass: #(#C #C #O #(a b c d)) with: #(a z b t) asOrderedCollection"	| ivs |	^anObjClass isNil		ifTrue: [ivOrderedCollection]		ifFalse: 			[ivs := anObjClass objIVs asOrderedCollection copy.			ivOrderedCollection do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!ObjV methodsFor: 'method management' stamp: 'StephaneDucasse 12/6/2017 09:52'!doesUnderstand: aSelector 	"Tell if the receiver has a method having <aSelector> as selector. self is anObjClass"	^self objMethodDict keys includes: aSelector! !!ObjV methodsFor: 'keyword management' stamp: 'StephaneDucasse 12/6/2017 09:52'!generateKeywords: anArray 	"Returns an array containing the keywords made from the collection of Symbol passed as argument"	"self new generateKeywords: #(titi toto lulu) "	^anArray collect: [:e | (e , ':') asSymbol]! !!ObjV methodsFor: 'instance initialization' stamp: 'StephaneDucasse 12/6/2017 09:52'!initializeUsing: anAlternatedArray 	"Returns the receiver an ObjObject initialized according to the directives given by anAlternateArray"	| ivValues |	ivValues := self 						returnValuesFrom: anAlternatedArray						followingSchema: self objClass objKeywords.	1 to:  ivValues size			do: [:i | self at: i + 1 put: (ivValues at: i)].	^ self ! !!ObjV methodsFor: 'keyword management' stamp: 'StephaneDucasse 12/6/2017 09:52'!keywordValue: aSymbol getFrom: anArray ifAbsent: aDefaultValue 	"precondition: ((length anArray) mod 2) = 0 	returns the value associated with the keyword represented by aSymbol 	in the initarg list represented by anArray."	"self new keywordValue: #titi getFrom: #(toto 12 titi 23) ifAbsent: 2"	"self new keywordValue: #titi getFrom: #(toto 23) ifAbsent: 2"	| i |	i := anArray indexOf: aSymbol ifAbsent: nil.	^i isNil 		ifTrue: [aDefaultValue] 		ifFalse: [anArray at: i + 1]! !!ObjV methodsFor: 'method lookup' stamp: 'StephaneDucasse 12/6/2017 09:52'!lookup: selector	"look for the method named <selector> starting in the receiver. 	The lookup is done for a message sent to <anObjObject>. self is an objClass"	^ self! !!ObjV methodsFor: 'method management' stamp: 'StephaneDucasse 12/6/2017 09:52'!methodWithHeader: col andBody: aString 	| block string resBlock |	string := self stringOfBlockBodyFromHeader: col andBody: aString.	block := Compiler evaluate: string.	"bind superclass to the superclass of the class defining the method"	resBlock := block value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [666]).	^resBlock! !!ObjV methodsFor: 'iv management' stamp: 'StephaneDucasse 12/6/2017 09:52'!numberOfIVs	"Returns the number of instance variables of the class an ObjClass"	^self objIVs size! !!ObjV methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objClass	"Receiver should be: anObjObject. Returns the class of the receiver (which is an ObjObject) and not its internal identification. Differs from classId  which is a primitive to access the structure representing a class"	^ self! !!ObjV methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objClassId	"Receiver should be: anObjObject. Returns the identifier that identifies the class of the receiver (an objObject). In this implementation we chose to use the class name as identifier"	^ self! !!ObjV methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objClassId: anObjClassId	"Receiver should be: anObjObject. Set the identifier that identifies the class of the receiver (anObjObject)."	^ self! !!ObjV methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objIVs	"Receiver should be: anObjClass. Returns the list of instance variables"	^ self! !!ObjV methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objIVs: anOrderedCollection	"Receiver should be: anObjClass. Set the list of instance variable names of the receiver (anObjClass)"	^ self! !!ObjV methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objKeywords	"Receiver should be: anObjClass. Returns the keyword list of the receiver (anObjClass)"	^ self! !!ObjV methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objKeywords: anOrderedCollection	"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"	^ self! !!ObjV methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objMethodDict	"Receiver should be: anObjClass. Returns the method dictionary of the receiver (anObjClass)"	^ self! !!ObjV methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objMethodDict: aDictionary	"Receiver should be: anObjClass. Sets the method dictionary of the receiver (anObjClass)"	^ self! !!ObjV methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objName	"Receiver should be: anObjClass. Returns the name of the receiver (anObjClass)"	^ self! !!ObjV methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objName: aName	"Receiver should be: anObjClass. Set the name of the receiver (anObjClass)"	^ self! !!ObjV methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objSuperclass	"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"	^Obj giveClassNamed: self objSuperclassId! !!ObjV methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objSuperclassId	"Receiver should be: anObjClass. Returns the superclass id of the receiver (anObjClass)"	^ self! !!ObjV methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 12/6/2017 09:52'!objSuperclassId: anObjClassId	"Receiver should be: anObjClass. Set the superclass id of the receiver (anObjClass)"	^ self! !!ObjV methodsFor: 'object structure offset' stamp: 'StephaneDucasse 12/6/2017 09:52'!offsetForClass	^1! !!ObjV methodsFor: 'class structure offset' stamp: 'StephaneDucasse 12/6/2017 09:52'!offsetForIVs	^4! !!ObjV methodsFor: 'class structure offset' stamp: 'StephaneDucasse 12/6/2017 09:52'!offsetForKeywords	^5! !!ObjV methodsFor: 'class structure offset' stamp: 'StephaneDucasse 12/6/2017 09:52'!offsetForMethodDict	^6! !!ObjV methodsFor: 'class structure offset' stamp: 'StephaneDucasse 12/6/2017 09:52'!offsetForName	^2! !!ObjV methodsFor: 'class structure offset' stamp: 'StephaneDucasse 12/6/2017 09:52'!offsetForSuperclass	^3! !!ObjV methodsFor: 'iv management' stamp: 'StephaneDucasse 12/6/2017 09:52'!offsetFromClassOfInstanceVariable: aSymbol	"Returns the index of the instance variable named aSymbol for an class anObjClass.	Returns 0 if the aSymbol is not present in the instance variable lists of anObjClass"	^ self! !!ObjV methodsFor: 'iv management' stamp: 'StephaneDucasse 12/6/2017 09:52'!offsetFromObjectOfInstanceVariable: aSymbol	"Returns the offset of the instance variable named aSymbol in the object anObjObject.	If aSymbol is not an instance variable is not an instance variable of the object raise an error"	^ self! !!ObjV methodsFor: 'printing' stamp: 'StephaneDucasse 12/6/2017 09:52'!printOn: aStream	aStream nextPutAll: 'an Obj object: '.		super printOn: aStream! !!ObjV methodsFor: 'method management' stamp: 'StephaneDucasse 12/6/2017 09:52'!removeMethod: aSelector	"Remove the method with aSelector <aSymbol> in the receiver. 	self is an objClass"	self objMethodDict removeKey: aSelector ifAbsent: [].	^self! !!ObjV methodsFor: 'keyword management' stamp: 'StephaneDucasse 12/6/2017 09:52'!returnValuesFrom: anInitargArray followingSchema: anArrayOfKeywords 	"Return the values associated with the keys. The extracted values are taken from <anInitargArray> 	and the return values are extracted according to the schema defined by the collection of keys <anArrayOfKeywords>"	"self new returnValuesFrom: #(lulu 22  titi 35)  followingSchema: #(titi toto lulu titi)  #(35 nil 22 35)"	^anArrayOfKeywords collect: 			[:e | 			self keywordValue: e				getFrom: anInitargArray 				ifAbsent: nil]! !!ObjV methodsFor: 'message passing' stamp: 'StephaneDucasse 12/6/2017 09:52'!send: selector withArguments: arguments	"send the message whose selector is <selector> to the receiver. The arguments of the messages are an array <arguments>. The method is lookep up in the class of the receiver. self is an objObject or a objClass."	^ self! !!ObjV methodsFor: 'message passing' stamp: 'StephaneDucasse 12/6/2017 09:52'!sendError: selector withArgs: arguments	"send error wrapping arguments into an array with the selector as first argument. Instead of an array we should create a message object."		^ self send: #error withArguments:  {(arguments copyWithFirst: selector)}	! !!ObjV methodsFor: 'method management' stamp: 'StephaneDucasse 12/6/2017 09:52'!stringOfBlockBodyFromHeader: col andBody: aString 	^ '[ :superClassOfClassDefiningTheMethod |		[ :objself ' , (self blockArgsFrom: col) , ' |					 ' , aString , '] ]'! !!ObjV methodsFor: 'message passing' stamp: 'StephaneDucasse 12/6/2017 09:52'!super: selector withArguments: arguments from: aSuperclass	"Invoke an oveeriden method named <selector> with an array of arguments <arguments>.  self is an objClass. aSuperclass should be the superclass of the class containing the method using super"	^ self! !!ObjV methodsFor: 'iv management' stamp: 'StephaneDucasse 12/6/2017 09:52'!valueOfInstanceVariable: aSymbol	^ self! !TestCase variableSubclass: #ObjExampleTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVLispSkeleton-AdvancedTests'!!ObjExampleTest class methodsFor: 'first user-defined metaclasses' stamp: ''!setMetaclassDefinition	"self setMetaclassDefinition"	| setClass |	setClass := Obj ObjClass				send: #new				withArguments: #(#(#name: #ObjSet #iv: #(#myInstances) #superclass: #ObjClass)).	"initialize on a metaclass"	setClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'			objself binarySuper: #initialize with: initArray from: superClassOfClassDefiningTheMethod.			objself send: #setIV				withArguments: (Array with: #myInstances with: OrderedCollection new).			objself'.	setClass addUnaryMethod: #instances		withBody: 'objself binarySend: #getIV with: #myInstances'.	setClass addMethod: #new		args: 'initArray'		withBody: 			'| newInst others |			newInst := objself super: #new withArguments: (Array with: initArray) from: superClassOfClassDefiningTheMethod.			others := objself unarySend: #instances.			others := others add: newInst;						yourself.			objself send: #setIV withArguments: (Array with: #myInstances with: others).			newInst'! !!ObjExampleTest class methodsFor: 'first user-defined metaclasses' stamp: 'StephaneDucasse 11/26/2014 22:04'!setMetaclassExample	"self setMetaclassExample"	| memoPointClass |	self setMetaclassDefinition.	memoPointClass := Obj ObjSet 						send: #new						withArguments: #(#(#name: #ObjMemoPoint  #iv: #() #superclass: #ObjPoint)).	memoPointClass send: #new withArguments: #(#(#x: 24 #y: 6)).	memoPointClass send: #new withArguments: #(#(#x: 15 #y: 10)).	^memoPointClass send: #instances withArguments: #().! !!ObjExampleTest methodsFor: 'setup' stamp: ''!abstractMetaclassDefinition 	(Obj giveClassNamed: #ObjClass)					 		send: #new							withArguments: #(#(#name: #ObjAbstractClass #iv: #() #superclass: #ObjClass)).	Obj ObjAbstractClass 		addMethod: #new		args: 'initArray'		withBody: 			' objself error: '' the class '' , objself objName asString , '' is abstract'''! !!ObjExampleTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:52'!defineObjAbstractPoint	(Obj ObjAbstractClass)		send: #new		withArguments: #(#(#name: #ObjAbstractPoint #iv: #() #superclass: #ObjObject)).	Obj ObjAbstractPoint		addUnaryMethod: #givex		withBody: 'objself  valueOfInstanceVariable: #x '.	Obj ObjAbstractPoint 		addUnaryMethod: #display		withBody: 			'Transcript cr;				show: ''aPoint with x = ''.			Transcript show: (objself send: #givex withArguments: #()) printString;				cr'.! !!ObjExampleTest methodsFor: 'setup' stamp: ''!defineObjPoint	Obj ObjClass send: #new		withArguments: #(#(#name: #ObjPoint #iv: #(#x #y) #superclass: #ObjAbstractPoint)).! !!ObjExampleTest methodsFor: 'setup' stamp: ''!setUp	Obj bootstrap.	self abstractMetaclassDefinition.	self defineObjAbstractPoint.	self defineObjPoint! !!ObjExampleTest methodsFor: 'test abstract' stamp: ''!testAbstractMetaclassExample	self should: [Obj ObjAbstractClass send: #new withArguments: #(#(#x: 24 #y: 6))] raise: Error.! !!ObjExampleTest methodsFor: 'test abstract' stamp: ''!testAbstractMetaclassExampleWithConcreteSubclass	self shouldnt: [Obj ObjPoint send: #new withArguments: #(#(#x: 24 #y: 6))]		raise: Error! !!ObjExampleTest methodsFor: 'test abstract' stamp: 'StephaneDucasse 11/27/2014 20:48'!testColoredPoint	| coloredPointClass aColoredPoint |	coloredPointClass := (Obj ObjClass)						 	send: #new 							withArguments: #((#name: #ObjColoredPoint 							           		   #iv: #(#color) 							            	  #superclass: #ObjPoint)).	aColoredPoint := coloredPointClass send: #new withArguments: #((#x: 24 #y: 6 #color: #blue)).		"first messages sent"	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 24.	aColoredPoint send: #setIV withArguments: #(#x 25).	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 25.	self assert: (aColoredPoint send: #getIV withArguments: #(#color)) = #blue.		"adding some methods"	coloredPointClass 		addUnaryMethod: #giveColor		withBody: 'objself send: #getIV withArguments: #(#color)'.	coloredPointClass 		addMethod: #setColor		args: 'col'		withBody:' objself send: #setIV withArguments: (Array with: #color with: col)'.	coloredPointClass addUnaryMethod: #display		withBody:  			'objself super: #display withArguments: #() from: superClassOfClassDefiningTheMethod.			Transcript cr;				show: '' with Color = ''.			Transcript show: (objself send: #giveColor withArguments: #()) printString;				cr'.	self assert: (aColoredPoint send: #giveColor withArguments: #()) = #blue.		self assert: (aColoredPoint send: #givex withArguments: #()) = 25.		aColoredPoint send: #display withArguments: #().! !TestCase subclass: #ObjTest	instanceVariableNames: 'objectClass aPoint coloredPointClass pointClass classClass aColoredPoint aIncrementalColoredPoint incrementalColoredPointClass'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVLispSkeleton'!!ObjTest methodsFor: 'setup' stamp: ''!assembleClassClass	classClass := Obj new: 6.	classClass at: classClass offsetForName put: #ObjClass.	classClass at: classClass offsetForClass put: #ObjClass.	classClass at: classClass offsetForIVs		put: #(#class #name #superclass #iv #keywords #methodDict).	classClass at: classClass offsetForKeywords		put: #(#name: #superclass: #iv: #keywords: #methodDict:).	classClass at: classClass offsetForSuperclass put: #ObjObject.	classClass at: classClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: classClass! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 10/22/2009 16:24'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint at: 1 put: #ObjColoredPoint.	aColoredPoint at: 2 put: 10.	aColoredPoint at: 3 put: 15.	aColoredPoint at: 4 put: #blue! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:36'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass at: pointClass offsetForName put: #ObjColoredPoint.	coloredPointClass at: pointClass offsetForClass put: #ObjClass.		"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."	coloredPointClass at: pointClass offsetForIVs put: #( #class #x #y #color).	coloredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.	coloredPointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 2/15/2011 16:10'!assembleIncrementalColoredInstance		aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.	aIncrementalColoredPoint at: 2 put: 10.	aIncrementalColoredPoint at: 3 put: 15.	aIncrementalColoredPoint at: 4 put: #blue! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:37'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass at: pointClass offsetForName put: #ObjIncrementalColoredPoint.	incrementalColoredPointClass at: pointClass offsetForClass put: #ObjClass.		"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."	incrementalColoredPointClass at: pointClass offsetForIVs put: #( #color).	incrementalColoredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.	incrementalColoredPointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/26/2014 16:01'!assembleObjectClass	objectClass := Obj new: 6.	objectClass at: objectClass offsetForName put: #ObjObject.	objectClass at: objectClass offsetForClass put: #ObjClass.	objectClass at: objectClass offsetForIVs put: #(#class).	objectClass at: objectClass offsetForKeywords put: #().	objectClass at: objectClass offsetForSuperclass put: nil.	objectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).	Obj declareClass: objectClass.	"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent	the superclass of ObjObject"	(objectClass at: objectClass offsetForMethodDict) at: #print		put: 			([:superClassOfClassDefiningTheMethod |				[:objself | 			Transcript show: 'I''am an Object';				cr]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #error		put: 			([:superClassOfClassDefiningTheMethod |				[:object :arrayOfArguments | 			Transcript show: 'Error: selector ' , arrayOfArguments first printString , ' not understood';				cr.				Error signal]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #getIV		put: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #setIV		put: 			([:superClassOfClassDefiningTheMethod | [:object :iv :val | 			object at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #bar		put: 			([:superClassOfClassDefiningTheMethod | [:objself | 					5]] value: nil).! !!ObjTest methodsFor: 'setup' stamp: ''!assemblePointClass	| cl |	cl := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (cl at: cl offsetForIVs) size.	pointClass at: pointClass offsetForName put: #ObjPoint.	pointClass at: pointClass offsetForClass put: #ObjClass.	pointClass at: pointClass offsetForIVs put: #(#class #x #y).	pointClass at: pointClass offsetForKeywords put: #(#x: #y:).	pointClass at: pointClass offsetForSuperclass put: #ObjObject.	pointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict) at: #x		put: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | [:objself | 			Transcript show: 'I''am a Point';				cr]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'ObjPoint>>foo';cr.				5				]] value: objectClass)! !!ObjTest methodsFor: 'setup' stamp: ''!assemblePointInstance	aPoint := Obj new: 3.	aPoint at: 1 put: #ObjPoint.	aPoint at: 2 put: 10.	aPoint at: 3 put: 15! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 2/15/2011 16:15'!setUp	"self new setUp"	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !!ObjTest methodsFor: 'step5-tests-allocate' stamp: 'StephaneDucasse 11/21/2015 15:44'!testAllocate  "(self  selector: #testAllocate) run"  | newInstance |  newInstance := pointClass allocateAnInstance.  self assert: (newInstance at: 1) = #ObjPoint.  self assert: (newInstance size) = 3.  self assert: (newInstance at: 2) isNil.  self assert: (newInstance at: 3) isNil.  self assert: (newInstance objClass = pointClass)! !!ObjTest methodsFor: 'utilities tests' stamp: ''!testBlockArgsFrom	self assert: (Obj new blockArgsFrom: ' abc def ghi ')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: 'abc def ghi')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: '')  = ''.! !!ObjTest methodsFor: 'utilities tests' stamp: 'NicoPAez 10/21/2010 10:22'!testBlockBodyFromHeaderAndBody	"a method with one argument: val"	self assert: (Obj new stringOfBlockBodyFromHeader: 'val' andBody: 'objself send: #setIV 										 withArguments: (Array with: #x with: val).')										= '[ :superClassOfClassDefiningTheMethod |		[ :objself :val |					 objself send: #setIV 										 withArguments: (Array with: #x with: val).] ]'.	"a method without arg"	self assert: (Obj new stringOfBlockBodyFromHeader: '' andBody: 'objself unarySend: #getx.') 	='[ :superClassOfClassDefiningTheMethod |		[ :objself  |					 objself unarySend: #getx.] ]'	! !!ObjTest methodsFor: 'step3-tests-class access' stamp: ''!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (aPoint objClass = pointClass)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:52'!testErrorRaisedSendWhenErrorInLookup	"(self  selector: #testErrorRaisedSendWhenErrorInLookup) run"		self should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/27/2014 21:15'!testErrorRedefinition	"(self  run: #testErrorRedefinition)"		self should: [aPoint send: #zork withArguments: #()] raise: Error.	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).		self assert: (aPoint send: #zork withArguments: #()) = 33.	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).	self assert: (aPoint send: #zork withArguments: #(44)) = 33.! !!ObjTest methodsFor: 'step4-tests-iv management' stamp: ''!testIVOffset	"(self  selector: #testIVOffset) run"	self assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).	self assert: ((pointClass offsetFromClassOfInstanceVariable: #lulu ) = 0)! !!ObjTest methodsFor: 'step4-tests-iv management' stamp: ''!testIVOffsetAndValue	"(self  selector: #testIVOffsetAndValue) run"	self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).	self assert: ((aPoint valueOfInstanceVariable: #x ) = 10)! !!ObjTest methodsFor: 'step7-tests-initialize' stamp: 'StephaneDucasse 11/21/2015 16:16'!testInitialize	"(self  selector: #testInitialize) run"	| newInstance  |	newInstance := pointClass allocateAnInstance.	newInstance initializeUsing: #(#y: 2 #z: 3 #t: 55 #x: 1).	self assert: (newInstance at: 1) equals: #ObjPoint.	self assert: (newInstance at: 2) equals: 1.	self assert: (newInstance at: 3) equals: 2.! !!ObjTest methodsFor: 'step8-tests-instance variable inheritance' stamp: ''!testInstanceVariableInheritance	"(self  selector: #testInstanceVariableInheritance) run"	"a better choice would be to throw an exception if there are duplicates"	self assert: 			((Obj new computeNewIVFrom: #(#a #b #c #d) asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #b #c #d #z #t) asOrderedCollection).	self assert: 			((Obj new computeNewIVFrom: #() asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #z #b #t) asOrderedCollection)! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'StephaneDucasse 2/15/2011 16:12'!testInstanceVariableInheritanceFromAClass	"(self  selector: #testInstanceVariableInheritanceFromAClass) run"		aIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).		self assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).	self assert: ((incrementalColoredPointClass offsetFromClassOfInstanceVariable: #x ) = 2).	! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'StephaneDucasse 2/15/2011 16:14'!testInstanceVariableInheritanceFromAObject	"(self  selector: #testInstanceVariableInheritanceFromAObject) run"		aIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).		self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).	self assert: ((aIncrementalColoredPoint offsetFromObjectOfInstanceVariable: #x ) = 2).			! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'JB 10/9/2009 16:52'!testInstanceVariableInheritanceNotFind	"(self  selector: #testInstanceVariableInheritanceNotFind) run"		self should: [aPoint offsetFromObjectOfInstanceVariable: #zork ] raise: Error.			! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'JB 10/13/2009 16:23'!testInstanceVariableInheritanceNumberOfInstanceVar	"(self  selector: #testInstanceVariableInheritanceNumberOfInstanceVar) run"		self assert: ((pointClass numberOfIVs ) = 3).	self assert: ((coloredPointClass numberOfIVs ) = 4).	! !!ObjTest methodsFor: 'step6-tests-keywords' stamp: ''!testKeywords	"(self  selector: #testKeywords) run"	| dummyObject |	dummyObject := Obj new.	self assert: 			((dummyObject generateKeywords: #(#titi #toto #lulu))				= #(#titi: #toto: #lulu:)).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 33 #x 23)				ifAbsent: 2) = 23).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 23)				ifAbsent: 2) = 2).	self assert: 			((dummyObject returnValuesFrom: #(#x 22 #y 35) followingSchema: #(#y #yy #x #y))				= #(35 nil 22 35))! !!ObjTest methodsFor: 'tests' stamp: ''!testMethodDefinition	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.	"define a unary method xx returning the receiver."	pointClass 		addMethod: #xx		args: ''		withBody: 'objself'.	self assert: (pointClass doesUnderstand: #xx).	self assert: (((pointClass bodyOfMethod: #xx) value: 22) = 22).	"define a unary method returning the slot x of the receiver"	pointClass 		addMethod: #getgetx		args: ''		withBody: 'objself valueOfInstanceVariable: #x'.	self assert: (pointClass doesUnderstand: #getgetx).	self assert: (((pointClass bodyOfMethod: #getgetx) value: aPoint) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookup	"(self  selector: #testMethodLookup) run"		self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookupFindSimpleMethod	"(self  selector: #testMethodLookupFindSimpleMethod) run"	self assert: ((pointClass lookup: #x)  isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookupFindSuperMethod	"(self  selector: #testMethodLookupFindSuperMethod) run"		self assert: ((coloredPointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:38'!testMethodLookupStop	"(self  selector: #testMethodLookupStop) run"		| foundMethod|	foundMethod := (pointClass lookup: #zork).	self assert: foundMethod isNil. 	"The method zork is NOT implement on pointClass, so nil is returned."	self should: [ pointClass sendError: #error withArgs: {aPoint}] raise: Error.		foundMethod := (pointClass lookup: #error).	self assert: (foundMethod isKindOf: BlockClosure).	self assert: ('*Error*' match: foundMethod printString).		"the message error defined on ObjObject requires two arguments: an object and a selector and it raises 	an error when executed. Open a Transcript to see the message trace"	self should:  [((pointClass lookup: #zork) value: 'r' value: #e)] raise: Error .! !!ObjTest methodsFor: 'tests' stamp: 'NicoPAez 10/21/2010 10:25'!testMethodManagement	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.		pointClass 		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).	self assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self assert: (pointClass doesUnderstand: #xx) not.	self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:51'!testMethodManagmentAddRemoveMethods	"(self  selector: #testMethodManagmentAddRemoveMethods) run"	pointClass 		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).	self assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self assert: (pointClass doesUnderstand: #xx) not.	self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:51'!testMethodManagmentBodyOfMethod	"(self  selector: #testMethodManagmentBodyOfMethod) run"		self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:52'!testMethodManagmentNotUnderstandBadMethod	"(self  selector: #testMethodManagmentNotUnderstandBadMethod) run"	self assert: (pointClass doesUnderstand: #xx) not.	! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:52'!testMethodManagmentUnderstandGoodMethod	"(self  selector: #testMethodManagmentUnderstandGoodMethod) run"	self assert: (pointClass doesUnderstand: #x).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:05'!testMethodNotFoundRaiseError	"(self  run: #testMethodNotFoundRaiseError)"	self should: [aPoint send: #zork withArguments: #()] raise: Error.! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/27/2014 12:18'!testMethodSelfSend	"(self  selector: #testMethodSelfSend) run"	"method found in the class PointClass"	self assert: ((aPoint send: #x withArguments: #()) = 10).	"method found in ObjClass"	self assert: ((aPoint send: #getIV withArguments: #(#x)) = 10).	"method found in ObjClass"	aPoint send: #setIV withArguments: #(y 22).	self assert: ((aPoint send: #getIV withArguments: #(#y)) = 22)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 11/26/2014 22:22'!testMethodSelfSendUnarySend	"(self  selector: #testMethodSelfSendUnarySend) run"	"method found in the class PointClass"	self assert: ((aPoint send: #x withArguments: #()) = 10).	"method found in the class PointClass"	self assert: ((aColoredPoint send: #x withArguments:#()) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:22'!testMethodSuperCall	"(self  selector: #testMethodSuperCall) run"	"foo in point return 5"	self assert: ((aPoint send: #foo withArguments: #()) = 5).	"foo in colored point is doing super foo + super foo"	self assert: ((aColoredPoint send: #foo withArguments: #()) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:23'!testMethodSuperCallOverBigHierarchy	"(self  selector: #testMethodSuperCallOverBigHierarchy) run"	"bar is defined in Object and not on Point"	self assert: (aPoint send: #bar withArguments: #()) = 5.	"bar on coloredPoint = super bar + super bar"	self assert: (aColoredPoint send: #bar withArguments: #()) = 10.! !!ObjTest methodsFor: 'utilities tests' stamp: ''!testMethodWithHeaderAndBody	"a method simply returning objself"	self assert: ((pointClass					methodWithHeader: ''					andBody: 'objself ') value: 2) = 2.		"a method returning its first none implicit arg"	self assert: ((pointClass 					methodWithHeader: 'val'					andBody: 'val ') value: 2 value: 33) = 33.	"a method returns its superclass of the class defining the method value"	"this anonymous method is defined in pointClass so its superclass pointer is objectClass"	self assert: ((pointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = objectClass .	self assert: ((coloredPointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = pointClass .! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:52'!testNilWhenErrorInLookup	"(self  selector: #testNilWhenErrorInLookup) run"		self assert: (pointClass lookup: #zork) isNil.	"The method zork is NOT implement on pointClass"	! !!ObjTest methodsFor: 'tests' stamp: 'SD 2/5/2013 16:47'!testPrimitiveStructure	"(self selector: #testPrimitiveStructure) run"		self assert: (pointClass objClassId = #ObjClass).	self assert: ((pointClass objName ) = #ObjPoint).	self assert: ((pointClass objSuperclassId ) = #ObjObject).	self assert: ((pointClass objIVs) = #(#class #x #y)).	self assert: ((pointClass objKeywords) = #(#x: #y:)).	self assert: ((pointClass objMethodDict) = nil) not! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjClassId	"(self selector: #testPrimitiveStructureObjClassId) run"	self assert: (pointClass objClassId = #ObjClass).! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'SD 2/5/2013 16:48'!testPrimitiveStructureObjClassIdForSimpleObject	"self run: #testPrimitiveStructureObjClassIdForSimpleObject"	self assert: (aPoint objClassId = #ObjPoint).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjIVs	"(self selector: #testPrimitiveStructureObjIVs) run"	self assert: ((pointClass objIVs) = #(#class #x #y)).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) = #(#x: #y:)).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjMethodDict	"(self selector: #testPrimitiveStructureObjMethodDict) run"	self assert: ((pointClass objMethodDict) = nil) not! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjName	"(self selector: #testPrimitiveStructureObjName) run"	self assert: ((pointClass objName ) = #ObjPoint).	! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjSuperclassId	"(self selector: #testPrimitiveStructureObjSuperclassId) run"	self assert: ((pointClass objSuperclassId ) = #ObjObject).! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 11/21/2015 18:24'!testRaisesErrorSendWhenErrorInLookup	"(self  selector: #testRaisesErrorSendWhenErrorInLookup) run"	self should: [ pointClass send: #zork withArguments: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:54'!testSendErrorRaisesErrorSendWhenErrorInLookup	"(self  selector: #testSendErrorRaisesErrorSendWhenErrorInLookup) run"		self should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !TestCase subclass: #ObjTestBootstrap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVLispSkeleton-AdvancedTests'!!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: 'StephaneDucasse 11/26/2014 21:56'!testCreateObjClassMessage	"(self selector: #testCreateObjClassMessage) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self assert: ((objClass send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass)).	self assert: (objClass send: #isClass withArguments: #()).	self assert: (objClass send: #isMetaclass withArguments: #())! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: 'StephaneDucasse 11/26/2014 21:57'!testCreateObjClassStructure	"(self selector: #testCreateObjClassStructure) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self assert: (objClass objName = #ObjClass).	self assert: (objClass objClassId = #ObjClass).	self assert: (objClass objSuperclassId = #ObjObject).	self assert: (objClass objIVs asArray = #(#class #name #superclass #iv #keywords #methodDict)).	self assert: (objClass objKeywords asArray = #(#name: #superclass: #iv: #keywords: #methodDict:))! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'StephaneDucasse 11/26/2014 21:59'!testCreateObjObjectInstanceMessage	"(self selector: #testCreateObjObjectInstanceMessage) run"	| pointClass objClass pointInstance |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objClass := Obj giveClassNamed: #ObjClass.	pointClass := objClass 							send: #new							withArguments: #(#(#name: #ObjPoint #superclass: #ObjObject #iv: #(#x #y))).	pointInstance := pointClass send: #new withArguments: #(#()).	self assert: (pointInstance objClassId = #ObjPoint).	self assert: ((pointInstance send: #getIV withArguments: #(#x)) = nil).	pointInstance send: #setIV withArguments: #(#x 25).	self assert:  ((pointInstance send: #getIV withArguments: #(x)) = 25 )! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'StephaneDucasse 11/26/2014 22:00'!testCreateObjObjectMessage	"(self selector: #testCreateObjObjectMessage) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self assert: (objObject send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass).	self assert: (objObject send: #isClass withArguments: #()) not.	self assert: (objObject send: #getIV withArguments: #(#class)) = #ObjClass! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'stephane.ducasse 9/29/2008 14:32'!testCreateObjObjectStructure	"(self selector: #testCreateObjObjectStructure) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self assert: (objObject objName = #ObjObject).	self assert: (objObject objClassId = #ObjClass).	self assert: (objObject objSuperclassId isNil).	self assert: (objObject objIVs asArray = #(#class)).	self assert: (objObject objKeywords asArray = #())! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: 'StephaneDucasse 11/26/2014 22:01'!testManuallyCreateObjClassAllocate	"(self selector: #testManuallyCreateObjClassAllocate) run"	| objClass emptyClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	emptyClass := objClass send: #allocate withArguments: #().	self assert: emptyClass objClassId = #ObjClass.	self assert:  emptyClass objSuperclassId isNil.	self assert:  emptyClass objIVs isNil.	self assert:  emptyClass objKeywords isNil.	self assert:  emptyClass objMethodDict isNil.	self assert:  emptyClass objName isNil! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: 'StephaneDucasse 11/26/2014 22:01'!testManuallyCreateObjClassStructure	"(self selector: #testManuallyCreateObjClassStructure) run"	| objClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	self assert: (objClass objName = #ObjClass).	self assert: (objClass objClassId = #ObjClass).	self assert: (objClass objClass == objClass).	self assert: (objClass objSuperclassId = #ObjObject).		"the fact that the created first class inherits form ObjObject is not necessary	because there is no super calls"	self assert: (objClass objIVs = #(#class #name #superclass #iv #keywords #methodDict)).	self assert: (objClass objKeywords = #(#name: #superclass: #iv: #keywords: #methodDict:))! !TestCase subclass: #RawObjTest	instanceVariableNames: 'objectClass aPoint coloredPointClass pointClass classClass aColoredPoint aIncrementalColoredPoint incrementalColoredPointClass'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVLispSkeleton'!!RawObjTest commentStamp: 'StephaneDucasse 11/17/2014 11:09' prior: 0!These tests are based on a setup that does not rely on structure for the accessors.!!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:10'!assembleClassClass	classClass := Obj new: 6.	classClass at: 2 put: #ObjClass.	classClass at: 1 put: #ObjClass.	classClass at: 4 put: #(#class #name #superclass #iv #keywords #methodDict).	classClass at: 5 put: #(#name: #superclass: #iv: #keywords: #methodDict:).	classClass at: 3 put: #ObjObject.	classClass at: 6 put: (IdentityDictionary new).	Obj declareClass: classClass! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint at: 1 put: #ObjColoredPoint.	aColoredPoint at: 2 put: 10.	aColoredPoint at: 3 put: 15.	aColoredPoint at: 4 put: #blue! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:38'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass at: 2 put: #ObjColoredPoint.	coloredPointClass at: 1 put: #ObjClass.	"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."	coloredPointClass at: 4 put: #( #class #x #y #color).	coloredPointClass at: 3 put: #ObjPoint.	coloredPointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assembleIncrementalColoredInstance		aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.	aIncrementalColoredPoint at: 2 put: 10.	aIncrementalColoredPoint at: 3 put: 15.	aIncrementalColoredPoint at: 4 put: #blue! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:39'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass at: 2 put: #ObjIncrementalColoredPoint.	incrementalColoredPointClass at: 1 put: #ObjClass.	"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."	incrementalColoredPointClass at: 4 put: #( #color).	incrementalColoredPointClass at: 3 put: #ObjPoint.	incrementalColoredPointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:12'!assembleObjectClass	objectClass := Obj new: 6.	objectClass at: 2 put: #ObjObject.	objectClass at: 1 put: #ObjClass.	objectClass at: objectClass offsetForIVs put: #(#class).	objectClass at: objectClass offsetForKeywords put: #().	objectClass at: objectClass offsetForSuperclass put: nil.	objectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).	Obj declareClass: objectClass.	"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent	the superclass of ObjObject"	(objectClass at: objectClass offsetForMethodDict) at: #print		put: 			([:superClassOfClassDefiningTheMethod |				[:objself | 			Transcript show: 'I''am an Object';				cr]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #error		put: 			([:superClassOfClassDefiningTheMethod |				[:object :selector | 			Transcript show: 'Error: selector ' , selector printString , ' not understood';				cr.				Error signal]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #getIV		put: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #setIV		put: 			([:superClassOfClassDefiningTheMethod | [:object :iv :val | 			object at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #bar		put: 			([:superClassOfClassDefiningTheMethod | [:objself | 					5]] value: nil).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:13'!assemblePointClass	| cl |	cl := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (cl at: cl offsetForIVs) size.	pointClass at: 2 put: #ObjPoint.	pointClass at: 1 put: #ObjClass.	pointClass at: 4 put: #(#class #x #y).	pointClass at: 5 put: #(#x: #y:).	pointClass at: 3 put: #ObjObject.	pointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict) at: #x		put: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | [:objself | 			Transcript show: 'I''am a Point';				cr]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'ObjPoint>>foo';cr.				5				]] value: objectClass)! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assemblePointInstance	aPoint := Obj new: 3.	aPoint at: 1 put: #ObjPoint.	aPoint at: 2 put: 10.	aPoint at: 3 put: 15! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!setUp	"self new setUp"	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !!RawObjTest methodsFor: 'step3-tests-class access' stamp: 'StephaneDucasse 11/17/2014 11:09'!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (aPoint objClass = pointClass)! !!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjClassId	"(self selector: #testPrimitiveStructureObjClassId) run"	self assert: (pointClass objClassId = #ObjClass).! !!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjClassIdForSimpleObject	"self run: #testPrimitiveStructureObjClassIdForSimpleObject"	self assert: (aPoint objClassId = #ObjPoint).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjIVs	"(self selector: #testPrimitiveStructureObjIVs) run"	self assert: ((pointClass objIVs) = #(#class #x #y)).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) = #(#x: #y:)).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjMethodDict	"(self selector: #testPrimitiveStructureObjMethodDict) run"	self assert: ((pointClass objMethodDict) = nil) not! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjName	"(self selector: #testPrimitiveStructureObjName) run"	self assert: ((pointClass objName ) = #ObjPoint).	! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjSuperclassId	"(self selector: #testPrimitiveStructureObjSuperclassId) run"	self assert: ((pointClass objSuperclassId ) = #ObjObject).! !ObjV initialize!