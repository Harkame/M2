SystemOrganization addCategory: #ObjVSkeleton!Inspector subclass: #ObjClassInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton'!!ObjClassInspector commentStamp: '<historical>' prior: 0!ObjClassInspector is special inspector to help inspecting ObjClass!!ObjClassInspector methodsFor: 'field list' stamp: ''!fieldIndex	"Answer the offset corresponding to the currently selected field."	^ self listOfClassFields indexOf: field! !!ObjClassInspector methodsFor: 'field list' stamp: ''!fieldList	"Answer an Array consisting of 'self' and the instance variable 	names of the inspected object. Up to 40 indices are given for 	variable length objects."	^ ((OrderedCollection with: 'self') addAll: self listOfClassFields ;yourself) asArray! !!ObjClassInspector methodsFor: 'field list' stamp: ''!fieldValue	(field = 'self' or: [field == nil]) ifTrue: [^object].	^ object basicAt: self fieldIndex! !!ObjClassInspector methodsFor: 'private' stamp: ''!listOfClassFields	"object objClass objIVs"	| class |	^object size isZero		ifTrue: [#()]		ifFalse: 			[(object at: 1) isNil				ifTrue: [#()]				ifFalse: 					[class := Obj giveClassNamed: (object at: 1) ifAbsent: [nil].					class isNil						ifTrue: [#()]						ifFalse: 							[| iv |							iv := class at: 4.							iv isNil								ifTrue: [#(#class #name #superclass #iv #keywords #methods)]								ifFalse: [class at: 4]]]]! !Array variableSubclass: #Obj	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton'!Obj class	instanceVariableNames: 'definedObjClasses'!Obj class	instanceVariableNames: 'definedObjClasses'!!Obj classSide methodsFor: 'bootstrap objClass manually' stamp: ''!bootstrap	"self bootstrap"		self initialize.	self manuallyCreateObjClass.	self createObjObject.	self createObjClass.! !!Obj classSide methodsFor: 'bootstrap objClass' stamp: ''!createObjClass	"self bootstrap"	| objClass |	objClass := self objClassStructure.	self defineAllocateMethodIn: objClass.	self defineNewMethodIn: objClass.	self defineInitializeMethodIn: objClass.	objClass 		addUnaryMethod: #isMetaclass		withBody: 'objself objIVs includes: #superclass'.		"an object is a class if is class is a metaclass. cool"		objClass 		addUnaryMethod: #isClass		withBody: 'objself objClass unarySend: #isMetaclass'.	^objClass! !!Obj classSide methodsFor: 'bootstrap objObject' stamp: ''!createObjObject	| objObject |	objObject := self objObjectStructure.	objObject addUnaryMethod: #class withBody: 'objself objClass'.	objObject addUnaryMethod: #isClass withBody: 'false'.	objObject addUnaryMethod: #isMetaclass withBody: 'false'. 	objObject 		addMethod: #error		args: 'selector'		withBody: 'Transcript show: ''error'''.	"some meta facilities"	objObject 		addMethod: #getIV		args: 'iv'		withBody: 'objself valueOfInstanceVariable: iv'.	objObject 		addMethod: #setIV		args: 'iv val'		withBody: 			' objself at: (objself offsetFromObjectOfInstanceVariable: iv) put: val'.	objObject 		addMethod: #initialize		args: 'initargs'		withBody: 'objself  initializeUsing: initargs'.	^objObject! !!Obj classSide methodsFor: 'global class repository management' stamp: ''!declareClass: anObjClass 	"To declare an ObjClass in the class repository"	| nameC |	nameC := anObjClass objName.	nameC isNil		ifFalse: [definedObjClasses at: nameC put: anObjClass]		ifTrue: [self error: 'The class does not have a name']! !!Obj classSide methodsFor: 'bootstrap objClass manually' stamp: ''!defineAllocateMethodIn: class 	class 		addUnaryMethod: #allocate 		withBody: 'objself allocateAnInstance'! !!Obj classSide methodsFor: 'bootstrap objClass' stamp: ''!defineInitializeMethodIn: objClass 	objClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'objself binarySuper: #initialize with: initArray from: superClassOfClassDefiningTheMethod.			objself objIVs: (objself							computeNewIVFrom: (Obj giveClassNamed: objself objSuperclassId) objIVs							with: objself objIVs).			objself computeAndSetKeywords.			objself objMethodDict: IdentityDictionary new.			Obj declareClass: objself.			objself'! !!Obj classSide methodsFor: 'bootstrap objClass manually' stamp: ''!defineManualInitializeMethodIn: class 	class 		addMethod: #initialize		args: 'initArray'		withBody: 				'| objsuperclass |			objself initializeUsing: initArray.	"Initialize a class as an object. In the bootstrapped system will be done via super"			objsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].			objsuperclass isNil				ifFalse: 					[objself						objIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]				ifTrue: 					[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].			objself				objKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).			objself objMethodDict: (IdentityDictionary new: 3).			Obj declareClass: objself.			objself'! !!Obj classSide methodsFor: 'bootstrap objClass manually' stamp: ''!defineNewMethodIn: class 	class 		addMethod: #new		args: 'initArray'		withBody: 			'(objself unarySend: #allocate) binarySend: #initialize with: initArray'.! !!Obj classSide methodsFor: 'tricks' stamp: 'stephane.ducasse 9/29/2008 14:25'!doesNotUnderstand: aMessage	"debugging >>>  default shiftDown ifTrue:[ self halt ]."	"Sensor shiftPressed ifTrue:[ self halt ]."		^ definedObjClasses at: aMessage selector! !!Obj classSide methodsFor: 'global class repository management' stamp: ''!giveClassNamed: aSymbol 	"Return the class defined in the class repository with the name aSymbol"	^ self giveClassNamed: aSymbol ifAbsent: [self error: ('The class ' , aSymbol printString , ' is not defined')]! !!Obj classSide methodsFor: 'global class repository management' stamp: ''!giveClassNamed: aSymbol ifAbsent: aBlock	^ definedObjClasses at: aSymbol ifAbsent: aBlock! !!Obj classSide methodsFor: 'initialize' stamp: ''!initialize	"self initialize"	 	definedObjClasses := IdentityDictionary new.	definedObjClasses at: #ObjClass put: nil.	definedObjClasses at: #ObjObject put: nil.! !!Obj classSide methodsFor: 'bootstrap objClass manually' stamp: ''!manualObjClassStructure	| class |	class := Obj new: 6.	class objClassId: #ObjClass.	class objName: #ObjClass.	class objIVs: #(#class #name #superclass #iv #keywords #methodDict).	class objKeywords: #(#name: #superclass: #iv: #keywords: #methodDict:).	class objSuperclassId: #ObjObject.	class objMethodDict: (IdentityDictionary new: 3).	^class! !!Obj classSide methodsFor: 'bootstrap objClass manually' stamp: ''!manuallyCreateObjClass	"self manuallyCreateObjClass"	| class |	class := self manualObjClassStructure.	Obj declareClass: class.	self defineManualInitializeMethodIn: class.	self defineNewMethodIn: class.	self defineAllocateMethodIn: class.	^class! !!Obj classSide methodsFor: 'bootstrap objClass' stamp: ''!objClassStructure	^(Obj giveClassNamed: #ObjClass) send: #new		withArguments: #(#(#name: #ObjClass #iv: #(#name #superclass #iv #keywords #methodDict) #superclass: #ObjObject))! !!Obj classSide methodsFor: 'bootstrap objObject' stamp: ''!objObjectStructure	^(Obj giveClassNamed: #ObjClass) 		send: #new		withArguments: #(#(#name: #ObjObject #iv: #(#class)))! !!Obj methodsFor: 'method management' stamp: ''!addMethod: aSelector args: aString withBody: aStringBlock 	"Define a method with selector <aSelector> , having a string representing the arguments (ie 'aNumber aStream') 	and a string representing the method body in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  objMethodDict at: aSelector put: (self methodWithHeader: aString andBody: aStringBlock).	^self! !!Obj methodsFor: 'method management' stamp: ''!addUnaryMethod: aSelector withBody: aStringBlock 	"Define a unary method with selector <aSelector> and a body <aaStringBlock> in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  addMethod: aSelector args: '' withBody: aStringBlock! !!Obj methodsFor: 'instance allocation' stamp: 'stephane.ducasse 9/29/2008 16:02'!allocateAnInstance	"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "	! !!Obj methodsFor: 'message passing' stamp: 'stephane.ducasse 9/29/2008 16:02'!binarySend: selector with: argument 	"send the message whose selector is <selector> to the receiver. The arguments of the messages	are an  <argument>. The method is lookep up in the class of the receiver. 	self is an objObject or a objClass."	! !!Obj methodsFor: 'message passing' stamp: 'stephane.ducasse 9/29/2008 16:02'!binarySuper: selector with: argument from: aSuperClass	"send the message whose selector is <selector> to the receiver. The arguments of the messages	are an  <argument>. The method is lookep up in the class of the receiver. 	self is an objObject or a objClass."	! !!Obj methodsFor: 'method management' stamp: 'stephane.ducasse 9/29/2008 14:11'!blockArgsFrom: aCol	"self basicNew blockArgsFrom: ' abc def ghi '"			| col st |	col := aCol findTokens: Character space.	col := col copyWithout: ''.	st := ''.	col do: [ :each | st := st , ':', each ] separatedBy: [st := st, ' '].	^ st! !!Obj methodsFor: 'method management' stamp: 'stephane.ducasse 9/29/2008 16:02'!bodyOfMethod: aSelector 	"Return the method associated with the selector <aSelector> in the receiver.	Return nil if the selector is not defined.  self is an objClass"	! !!Obj methodsFor: 'keyword management' stamp: 'stephane.ducasse 10/13/2008 14:54'!computeAndSetKeywords	"Compute the keywords of a given class.  As the class of an object should not be changed.	 the keywords should note contain the keyword class. self is anObjClass"	self objKeywords: (self generateKeywords: (self objIVs copyWithout: #class))! !!Obj methodsFor: 'iv inheritance' stamp: 'stephane.ducasse 10/13/2008 14:57'!computeNewIVFrom: superIVOrdCol with: localIVOrdCol	"Returns an ordered collection that is the union without duplicate of ivOfSuper and ivOrderedCollection.	Important the order of the instance variable is conserved"	| ivs |	^superIVOrdCol isNil 		ifTrue: [localIVOrdCol]		ifFalse: 			[ivs := superIVOrdCol asOrderedCollection copy.			localIVOrdCol do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!Obj methodsFor: 'iv inheritance' stamp: ''!computeNewIVFromClass: anObjClass with: ivOrderedCollection 	"Obj computeNewIVFromClass: #(#C #C #O #(a b c d)) with: #(a z b t) asOrderedCollection"	| ivs |	^anObjClass isNil		ifTrue: [ivOrderedCollection]		ifFalse: 			[ivs := anObjClass objIVs asOrderedCollection copy.			ivOrderedCollection do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!Obj methodsFor: 'debugging' stamp: ''!debug	"(self giveClassNamed: #ObjClass) debug"	"(self giveClassNamed: #ObjSet) debug"	"ObjExtension new debug"	"|aPt|	aPt := ObjExtension new: 3.	aPt at: 1 put: #ObjPoint.	aPt debug"	"|aPt|	aPt := ObjExtension new: 3.	aPt at: 1 put: #ObjPoint3.	aPt debug"	ObjClassInspector openOn: self! !!Obj methodsFor: 'method management' stamp: ''!doesUnderstand: aSelector 	"Tell if the receiver has a method having <aSelector> as selector. self is anObjClass"	^self objMethodDict keys includes: aSelector! !!Obj methodsFor: 'keyword management' stamp: ''!generateKeywords: anArray 	"Returns an array containing the keywords made from the collection of Symbol passed as argument"	"self new generateKeywords: #(titi toto lulu) "	^anArray collect: [:e | (e , ':') asSymbol]! !!Obj methodsFor: 'instance initialization' stamp: 'stephane.ducasse 9/29/2008 15:11'!initializeUsing: anAlternatedArray 	"Returns the receiver an ObjObject initialized according to the directives given by anAlternateArray"	| ivValues |	ivValues := self  returnValuesFrom: anAlternatedArray				followingSchema: self objClass objKeywords.	1 to:  ivValues size			do: [:i | self at: i + 1 put: (ivValues at: i)].	^ self ! !!Obj methodsFor: 'keyword management' stamp: ''!keywordValue: aSymbol getFrom: anArray ifAbsent: aDefaultValue 	"precondition: ((length anArray) mod 2) = 0 	returns the value associated with the keyword represented by aSymbol 	in the initarg list represented by anArray."	"self new keywordValue: #titi getFrom: #(toto 12 titi 23) ifAbsent: 2"	"self new keywordValue: #titi getFrom: #(toto 23) ifAbsent: 2"	| i |	i := anArray indexOf: aSymbol ifAbsent: nil.	^i isNil 		ifTrue: [aDefaultValue] 		ifFalse: [anArray at: i + 1]! !!Obj methodsFor: 'method lookup' stamp: 'stephane.ducasse 9/29/2008 16:03'!lookup: selector for: anObjObject 	"look for the method named <selector> starting in the receiver. 	The lookup is done for a message sent to <anObjObject>. self is an objClass"		! !!Obj methodsFor: 'method management' stamp: 'stephane.ducasse 9/29/2008 14:38'!methodWithHeader: col andBody: aString 	| block string resBlock |	string := self stringOfBlockBodyFromHeader: col andBody: aString.	block := Compiler evaluate: string.	block fixTemps.	"bind superclass to the superclass of the class defining the method"	resBlock := block value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [666]).	^resBlock! !!Obj methodsFor: 'iv management' stamp: ''!numberOfIVs	"Returns the number of instance variables of the class an ObjClass"	^self objIVs size! !!Obj methodsFor: 'object structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:04'!objClass	"Returns the ObjClass object of the object and not its internal identification. Differs from classId  which is a primitive 	to access the structure representing a class"! !!Obj methodsFor: 'object structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:04'!objClassId	"Returns the identifier that identifies the class of the object. In this implementation we chose to use the class name as identifier"	! !!Obj methodsFor: 'object structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:04'!objClassId: anObjClassId	"Set the identifier that identifies the class of the object."		! !!Obj methodsFor: 'class structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:04'!objIVs	! !!Obj methodsFor: 'class structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:04'!objIVs: anOrderedCollection 	"Set the list of instance variable names of anObjClass"	! !!Obj methodsFor: 'class structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:04'!objKeywords	"Returns the keyword list of an ObjClass"	! !!Obj methodsFor: 'class structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:05'!objKeywords: anOrderedCollection	"Sets the list of keywords of an ObjClass. Note that this method is just an accessor and does not compute the actual list of keywords"	! !!Obj methodsFor: 'class structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:05'!objMethodDict	"Returns the method dictionary of an ObjClass"! !!Obj methodsFor: 'class structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:05'!objMethodDict: aDictionary 	"Sets the method dictionary of an ObjClass"	! !!Obj methodsFor: 'class structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:05'!objName	"Returns the name of an ObjClass"	! !!Obj methodsFor: 'class structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:05'!objName: aName 	"Set the name of an ObjClass"	! !!Obj methodsFor: 'class structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:06'!objSuperclassId	"Returns the superclass id of anObjClass"	! !!Obj methodsFor: 'class structure primitive' stamp: 'stephane.ducasse 9/29/2008 16:06'!objSuperclassId: anObjClassId	"Set the superclass id of anObjClass"	! !!Obj methodsFor: 'object structure offset' stamp: ''!offsetForClass	^1! !!Obj methodsFor: 'class structure offset' stamp: ''!offsetForIVs	^4! !!Obj methodsFor: 'class structure offset' stamp: ''!offsetForKeywords	^5! !!Obj methodsFor: 'class structure offset' stamp: ''!offsetForMethodDict	^6! !!Obj methodsFor: 'class structure offset' stamp: ''!offsetForName	^2! !!Obj methodsFor: 'class structure offset' stamp: ''!offsetForSuperclass	^3! !!Obj methodsFor: 'iv management' stamp: 'stephane.ducasse 9/29/2008 16:07'!offsetFromClassOfInstanceVariable: aSymbol 	"Returns the index of the instance variable named aSymbol for an class anObjClass.	Returns 0 if the aSymbol is not present in the instance variable lists of anObjClass"	! !!Obj methodsFor: 'iv management' stamp: 'stephane.ducasse 9/29/2008 16:07'!offsetFromObjectOfInstanceVariable: aSymbol	"Returns the offset of the instance variable named aSymbol in the object anObjObject.	If aSymbol is not an instance variable is not an instance variable of the object raise an error"	! !!Obj methodsFor: 'printing' stamp: ''!printOn: aStream	aStream nextPutAll: 'an Obj object: '.		super printOn: aStream! !!Obj methodsFor: 'method management' stamp: ''!removeMethod: aSelector	"Remove the method with aSelector <aSymbol> in the receiver. 	self is an objClass"	self objMethodDict removeKey: aSelector ifAbsent: [].	^self! !!Obj methodsFor: 'keyword management' stamp: ''!returnValuesFrom: anInitargArray followingSchema: anArrayOfKeywords 	"Return the values associated with the keys. The extracted values are taken from <anInitargArray> 	and the return values are extracted according to the schema defined by the collection of keys <anArrayOfKeywords>"	"self new returnValuesFrom: #(lulu 22  titi 35)  followingSchema: #(titi toto lulu titi)  #(35 nil 22 35)"	^anArrayOfKeywords collect: 			[:e | 			self keywordValue: e				getFrom: anInitargArray 				ifAbsent: nil]! !!Obj methodsFor: 'message passing' stamp: 'stephane.ducasse 9/29/2008 14:26'!send: selector withArguments: arguments 	"send the message whose selector is <selector> to the receiver. The arguments of the messages	are an array <arguments>. The method is lookep up in the class of the receiver. 	self is an objObject or a objClass."	| ans |	ans := (self objClass lookup: selector for: self)				valueWithArguments: (Array with: self) , arguments.	^ ans! !!Obj methodsFor: 'method management' stamp: 'stephane.ducasse 9/29/2008 14:39'!stringOfBlockBodyFromHeader: col andBody: aString 	^ '[ :superClassOfClassDefiningTheMethod |		[ :objself ' , (self blockArgsFrom: col) , ' |					 ' , aString , '] fixTemps]'! !!Obj methodsFor: 'message passing' stamp: 'stephane.ducasse 9/29/2008 16:08'!super: selector withArguments: arguments from: aSuperclass	"Invoke an oveeriden method named <selector> with an array of arguments <arguments>. 	self is an objClass. aSuperclass should be the superclass of the class containing the method using super"	! !!Obj methodsFor: 'message passing' stamp: ''!unarySend: selector 	| ans |	ans := (self objClass lookup: selector for: self) value: self.	^ ans! !!Obj methodsFor: 'message passing' stamp: 'stephane.ducasse 9/29/2008 16:08'!unarySuper: selector from: anObjClass	"anObjClass should be the superclass of the class containing the method using super"	! !!Obj methodsFor: 'iv management' stamp: ''!valueOfInstanceVariable: aSymbol 	^self at: (self offsetFromObjectOfInstanceVariable: aSymbol)! !TestCase variableSubclass: #ObjExampleTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton'!!ObjExampleTest classSide methodsFor: 'first user-defined metaclasses' stamp: ''!setMetaclassDefinition	"self setMetaclassDefinition"	| setClass |	setClass := Obj ObjClass				send: #new				withArguments: #(#(#name: #ObjSet #iv: #(#myInstances) #superclass: #ObjClass)).	"initialize on a metaclass"	setClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'			objself binarySuper: #initialize with: initArray from: superClassOfClassDefiningTheMethod.			objself send: #setIV				withArguments: (Array with: #myInstances with: OrderedCollection new).			objself'.	setClass addUnaryMethod: #instances		withBody: 'objself binarySend: #getIV with: #myInstances'.	setClass addMethod: #new		args: 'initArray'		withBody: 			'| newInst others |			newInst := objself super: #new withArguments: (Array with: initArray) from: superClassOfClassDefiningTheMethod.			others := objself unarySend: #instances.			others := others add: newInst;						yourself.			objself send: #setIV withArguments: (Array with: #myInstances with: others).			newInst'! !!ObjExampleTest classSide methodsFor: 'first user-defined metaclasses' stamp: ''!setMetaclassExample	"self setMetaclassExample"	| memoPointClass |	self setMetaclassDefinition.	memoPointClass := Obj ObjSet 						send: #new						withArguments: #(#(#name: #ObjMemoPoint 									       #iv: #() #superclass: #ObjPoint)).	memoPointClass send: #new withArguments: #(#(#x: 24 #y: 6)).	memoPointClass send: #new withArguments: #(#(#x: 15 #y: 10)).	memoPointClass debug.	^memoPointClass unarySend: #instances! !!ObjExampleTest methodsFor: 'setup' stamp: 'stephane.ducasse 10/13/2008 16:00'!abstractMetaclassDefinition 	! !!ObjExampleTest methodsFor: 'setup' stamp: ''!defineObjAbstractPoint	(Obj ObjAbstractClass)		send: #new		withArguments: #(#(#name: #ObjAbstractPoint #iv: #() #superclass: #ObjObject)).	Obj ObjAbstractPoint		addUnaryMethod: #givex		withBody: 'objself  valueOfInstanceVariable: #x '.	Obj ObjAbstractPoint 		addUnaryMethod: #display		withBody: 			'Transcript cr;				show: ''aPoint with x = ''.			Transcript show: (objself unarySend: #givex) printString;				cr'.! !!ObjExampleTest methodsFor: 'setup' stamp: 'stephane.ducasse 10/13/2008 16:00'!defineObjPoint	! !!ObjExampleTest methodsFor: 'setup' stamp: ''!setUp	Obj bootstrap.	self abstractMetaclassDefinition.	self defineObjAbstractPoint.	self defineObjPoint! !!ObjExampleTest methodsFor: 'test abstract' stamp: ''!testAbstractMetaclassExample	self should: [Obj ObjAbstractClass send: #new withArguments: #(#(#x: 24 #y: 6))] raise: Error.! !!ObjExampleTest methodsFor: 'test abstract' stamp: ''!testAbstractMetaclassExampleWithConcreteSubclass	self shouldnt: [Obj ObjPoint send: #new withArguments: #(#(#x: 24 #y: 6))]		raise: Error! !!ObjExampleTest methodsFor: 'test abstract' stamp: 'stephane.ducasse 10/13/2008 16:01'!testColoredPoint	| coloredPointClass aColoredPoint |		"add class definition here"	aColoredPoint := coloredPointClass send: #new withArguments: #((#x: 24 #y: 6 #color: #blue)).		"first messages sent"	self assert: (aColoredPoint binarySend: #getIV with: #x) = 24.	aColoredPoint send: #setIV withArguments: #(#x 25).	self assert: (aColoredPoint binarySend: #getIV with: #x) = 25.	self assert: (aColoredPoint binarySend: #getIV with: #color) = #blue.		"adding some methods"	coloredPointClass 		addUnaryMethod: #giveColor		withBody: 'objself binarySend: #getIV with: #color'.	coloredPointClass 		addMethod: #setColor		args: 'col'		withBody:' objself send: #setIV withArguments: (Array with: #color with: col)'.	coloredPointClass addUnaryMethod: #display		withBody:  			'objself ... sniff no code :)'.							self assert: (aColoredPoint unarySend: #giveColor) = #blue.		self assert: (aColoredPoint unarySend: #givex) = 25.		aColoredPoint unarySend: #display! !TestCase subclass: #ObjTest	instanceVariableNames: 'objectClass aPoint coloredPointClass pointClass classClass aColoredPoint'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton'!!ObjTest methodsFor: 'setup' stamp: ''!assembleClassClass	classClass := Obj new: 6.	classClass at: classClass offsetForName put: #ObjClass.	classClass at: classClass offsetForClass put: #ObjClass.	classClass at: classClass offsetForIVs		put: #(#class #name #superclass #iv #keywords #methodDict).	classClass at: classClass offsetForKeywords		put: #(#name: #superclass: #iv: #keywords: #methodDict:).	classClass at: classClass offsetForSuperclass put: #ObjObject.	classClass at: classClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: classClass! !!ObjTest methodsFor: 'setup' stamp: ''!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint at: 1 put: #ObjColoredPoint.	aColoredPoint at: 2 put: 10.	aColoredPoint at: 3 put: 15.	aColoredPoint at: 3 put: #blue! !!ObjTest methodsFor: 'setup' stamp: ''!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass at: pointClass offsetForName put: #ObjColoredPoint.	coloredPointClass at: pointClass offsetForClass put: #ObjClass.	coloredPointClass at: pointClass offsetForIVs put: #(#color).	coloredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.	coloredPointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself unarySuper: #foo from: superClassOfClassDefiningTheMethod) + (objself unarySuper: #foo from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself unarySuper: #bar from: superClassOfClassDefiningTheMethod) + (objself unarySuper: #bar from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!ObjTest methodsFor: 'setup' stamp: 'stephane.ducasse 10/13/2008 15:29'!assembleObjectClass	objectClass := Obj new: 6.	objectClass at: objectClass offsetForName put: #ObjObject.	objectClass at: objectClass offsetForClass put: #ObjClass.	objectClass at: objectClass offsetForIVs put: #(#class).	objectClass at: objectClass offsetForKeywords put: #().	objectClass at: objectClass offsetForSuperclass put: nil.	objectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).	Obj declareClass: objectClass.	"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent	the superclass of ObjObject"	(objectClass at: objectClass offsetForMethodDict) at: #print		put: 			([:superClassOfClassDefiningTheMethod |				[:objself | 			Transcript show: 'I''am an Object';				cr]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #error		put: 			([:superClassOfClassDefiningTheMethod |				[:object :selector | 			Transcript show: 'Error: selector ' , selector printString , 'not understood';				cr.				object error]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #getIV		put: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #setIV		put: 			([:superClassOfClassDefiningTheMethod | [:object :iv :val | 			object at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #bar		put: 			([:superClassOfClassDefiningTheMethod | [:objself | 					5]] value: nil).! !!ObjTest methodsFor: 'setup' stamp: ''!assemblePointClass	| cl |	cl := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (cl at: cl offsetForIVs) size.	pointClass at: pointClass offsetForName put: #ObjPoint.	pointClass at: pointClass offsetForClass put: #ObjClass.	pointClass at: pointClass offsetForIVs put: #(#class #x #y).	pointClass at: pointClass offsetForKeywords put: #(#x: #y:).	pointClass at: pointClass offsetForSuperclass put: #ObjObject.	pointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict) at: #x		put: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | [:objself | 			Transcript show: 'I''am a Point';				cr]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'ObjPoint>>foo';cr.				5				]] value: objectClass)! !!ObjTest methodsFor: 'setup' stamp: ''!assemblePointInstance	aPoint := Obj new: 3.	aPoint at: 1 put: #ObjPoint.	aPoint at: 2 put: 10.	aPoint at: 3 put: 15! !!ObjTest methodsFor: 'setup' stamp: ''!setUp	"self new setUp"	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.! !!ObjTest methodsFor: 'tests' stamp: 'stephane.ducasse 9/29/2008 13:56'!testAllocate	"(self  selector: #testAllocate) run"	| newInstance testInstance |	testInstance := Obj new: 3.	testInstance at: 1 put: #ObjPoint.	newInstance := pointClass allocateAnInstance.	self assert: (newInstance = testInstance).	self assert: (newInstance objClass = pointClass)! !!ObjTest methodsFor: 'utilities tests' stamp: ''!testBlockArgsFrom	self assert: (Obj new blockArgsFrom: ' abc def ghi ')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: 'abc def ghi')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: '')  = ''.! !!ObjTest methodsFor: 'utilities tests' stamp: 'stephane.ducasse 9/29/2008 14:52'!testBlockBodyFromHeaderAndBody	"a method with one argument: val"	self assert: (Obj new stringOfBlockBodyFromHeader: 'val' andBody: 'objself send: #setIV 										 withArguments: (Array with: #x with: val).')										= '[ :superClassOfClassDefiningTheMethod |		[ :objself :val |					 objself send: #setIV 										 withArguments: (Array with: #x with: val).] fixTemps]'.	"a method without arg"	self assert: (Obj new stringOfBlockBodyFromHeader: '' andBody: 'objself unarySend: #getx.') 	='[ :superClassOfClassDefiningTheMethod |		[ :objself  |					 objself unarySend: #getx.] fixTemps]'	! !!ObjTest methodsFor: 'tests' stamp: ''!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (aPoint objClass = pointClass)! !!ObjTest methodsFor: 'tests' stamp: ''!testErrorRedefinition	"(self  run: #testErrorRedefinition)"		self should: [aPoint unarySend: #zork] raise: Error.	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself  | 33]] value: objectClass).		self assert: (aPoint unarySend: #zork) = 33.	"this is not enough since we redefined error as a unary method here but it is a binary and it should work for all of them.	In fact we have to reify the message and discard the computation"	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).	self assert: (aPoint binarySend: #zork with: 44) = 33.! !!ObjTest methodsFor: 'tests' stamp: ''!testIVOffset	"(self  selector: #testIVOffset) run"	self assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).	self assert: ((pointClass offsetFromClassOfInstanceVariable: #lulu ) = 0)! !!ObjTest methodsFor: 'tests' stamp: ''!testIVOffsetAndValue	"(self  selector: #testIVOffsetAndValue) run"	self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).	self assert: ((aPoint valueOfInstanceVariable: #x ) = 10)! !!ObjTest methodsFor: 'tests' stamp: ''!testInitialize	"(self  selector: #testInitialize) run"	| newInstance testInstance |	newInstance := pointClass allocateAnInstance.	testInstance := Obj new: 3.	testInstance at: 1 put: #ObjPoint.	testInstance at: 2 put: 1.	testInstance at: 3 put: 2.	newInstance initializeUsing: #(#y: 2 #z: 3 #t: 55 #x: 1).	self assert: (newInstance = testInstance)! !!ObjTest methodsFor: 'tests' stamp: ''!testInstanceVariableInheritance	"(self  selector: #testInstanceVariableInheritance) run"	"a better choice would be to throw an exception if there are duplicates"	self assert: 			((Obj new computeNewIVFrom: #(#a #b #c #d) asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #b #c #d #z #t) asOrderedCollection).	self assert: 			((Obj new computeNewIVFrom: #() asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #z #b #t) asOrderedCollection)! !!ObjTest methodsFor: 'tests' stamp: ''!testKeywords	"(self  selector: #testKeywords) run"	| dummyObject |	dummyObject := Obj new.	self assert: 			((dummyObject generateKeywords: #(#titi #toto #lulu))				= #(#titi: #toto: #lulu:)).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 33 #x 23)				ifAbsent: 2) = 23).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 23)				ifAbsent: 2) = 2).	self assert: 			((dummyObject returnValuesFrom: #(#x 22 #y 35) followingSchema: #(#y #yy #x #y))				= #(35 nil 22 35))! !!ObjTest methodsFor: 'tests' stamp: ''!testMethodDefinition	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.	"define a unary method xx returning the receiver."	pointClass 		addMethod: #xx		args: ''		withBody: 'objself'.	self assert: (pointClass doesUnderstand: #xx).	self assert: (((pointClass bodyOfMethod: #xx) value: 22) = 22).	"define a unary method returning the slot x of the receiver"	pointClass 		addMethod: #getgetx		args: ''		withBody: 'objself valueOfInstanceVariable: #x'.	self assert: (pointClass doesUnderstand: #getgetx).	self assert: (((pointClass bodyOfMethod: #getgetx) value: aPoint) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'stephane.ducasse 9/29/2008 16:00'!testMethodLookup	"(self  selector: #testMethodLookup) run"		self assert: ((pointClass lookup: #x for: aPoint) isKindOf: BlockContext)! !!ObjTest methodsFor: 'tests' stamp: ''!testMethodManagment	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.		pointClass 		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).	self assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self assert: (pointClass doesUnderstand: #xx) not.	self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests' stamp: ''!testMethodNotFoundRaiseError	"(self  run: #testMethodNotFoundRaiseError)"	self should: [aPoint unarySend: #zork] raise: Error.! !!ObjTest methodsFor: 'tests' stamp: ''!testMethodSelfSend	"(self  selector: #testMethodSelfSend) run"	"method found in the class PointClass"	self assert: ((aPoint unarySend: #x) = 10).	"method found in ObjClass"	self assert: ((aPoint binarySend: #getIV with: #x) = 10).	"method found in ObjClass"	aPoint send: #setIV withArguments: #(y 22).	self assert: ((aPoint binarySend: #getIV with: #y) = 22)! !!ObjTest methodsFor: 'tests' stamp: ''!testMethodSuperCall	"(self  selector: #testMethodSuperCall) run"	"foo in point return 5"	self assert: ((aPoint unarySend: #foo) = 5).	"foo in colored point is doing super foo + super foo"	self assert: ((aColoredPoint unarySend: #foo) = 10).! !!ObjTest methodsFor: 'tests' stamp: ''!testMethodSuperCallOverBigHierarchy	"(self  selector: #testMethodSuperCallOverBigHierarchy) run"	"bar is defined in Object and not on Point"	self assert: (aPoint unarySend: #bar) = 5.	"bar on coloredPoint = super bar + super bar"	self assert: (aColoredPoint unarySend: #bar) = 10.! !!ObjTest methodsFor: 'utilities tests' stamp: ''!testMethodWithHeaderAndBody	"a method simply returning objself"	self assert: ((pointClass					methodWithHeader: ''					andBody: 'objself ') value: 2) = 2.		"a method returning its first none implicit arg"	self assert: ((pointClass 					methodWithHeader: 'val'					andBody: 'val ') value: 2 value: 33) = 33.	"a method returns its superclass of the class defining the method value"	"this anonymous method is defined in pointClass so its superclass pointer is objectClass"	self assert: ((pointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = objectClass .	self assert: ((coloredPointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = pointClass .! !!ObjTest methodsFor: 'tests' stamp: ''!testPrimitiveStructure	"(self selector: #testPrimitiveStructure) run"	self assert: (pointClass objClassId = #ObjClass).	self assert: ((pointClass objName ) = #ObjPoint).	self assert: ((pointClass objSuperclassId ) = #ObjObject).	self assert: ((pointClass objIVs) = #(#class #x #y)).	self assert: ((pointClass objKeywords) = #(#x: #y:)).	self assert: ((pointClass objMethodDict) = nil) not! !TestCase subclass: #ObjTestBootstrap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ObjVSkeleton'!!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: ''!testCreateObjClassMessage	"(self selector: #testCreateObjClassMessage) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self		should: [(objClass unarySend: #class) = (Obj giveClassNamed: #ObjClass)].	self should: [objClass unarySend: #isClass].	self should: [objClass unarySend: #isMetaclass]! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: ''!testCreateObjClassStructure	"(self selector: #testCreateObjClassStructure) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self should: [objClass objName = #ObjClass].	self should: [objClass objClassId = #ObjClass].	self should: [objClass objSuperclassId = #ObjObject].	self should: 			[objClass objIVs asArray				= #(#class #name #superclass #iv #keywords #methodDict)].	self should: 			[objClass objKeywords asArray				= #(#name: #superclass: #iv: #keywords: #methodDict:)]! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: ''!testCreateObjObjectInstanceMessage	"(self selector: #testCreateObjObjectInstanceMessage) run"	| pointClass objClass pointInstance |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objClass := Obj giveClassNamed: #ObjClass.	pointClass := objClass send: #new				withArguments: #(#(#name: #ObjPoint 								  #superclass: #ObjObject #iv: #(#x #y))).	pointInstance := pointClass send: #new withArguments: #(#()).	self should: [pointInstance objClassId = #ObjPoint].	self should: [(pointInstance binarySend: #getIV with: #x) = nil].	self should: 			[pointInstance send: #setIV withArguments: #(#x 25).			(pointInstance binarySend: #getIV with: #x) = 25]! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: ''!testCreateObjObjectMessage	"(self selector: #testCreateObjObjectMessage) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self		should: [(objObject unarySend: #class) = (Obj giveClassNamed: #ObjClass)].	self should: [(objObject unarySend: #isClass) not].	self should: [(objObject binarySend: #getIV with: #class) = #ObjClass]! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'stephane.ducasse 9/29/2008 14:32'!testCreateObjObjectStructure	"(self selector: #testCreateObjObjectStructure) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self assert: (objObject objName = #ObjObject).	self assert: (objObject objClassId = #ObjClass).	self assert: (objObject objSuperclassId isNil).	self assert: (objObject objIVs asArray = #(#class)).	self assert: (objObject objKeywords asArray = #())! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: ''!testManuallyCreateObjClassAllocate	"(self selector: #testManuallyCreateObjClassAllocate) run"	| objClass emptyClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	emptyClass := objClass unarySend: #allocate.	self assert: emptyClass objClassId = #ObjClass.	self assert:  emptyClass objSuperclassId isNil.	self assert:  emptyClass objIVs isNil.	self assert:  emptyClass objKeywords isNil.	self assert:  emptyClass objMethodDict isNil.	self assert:  emptyClass objName isNil! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: ''!testManuallyCreateObjClassStructure	"(self selector: #testManuallyCreateObjClassStructure) run"	| objClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	self assert: (objClass objName = #ObjClass).	self assert: (objClass objClassId = #ObjClass).	self assert: (objClass objClass == objClass).	self assert: (objClass objSuperclassId = #ObjObject).		"the fact that the created first class inherits form ObjObject is not necessary	because there is no super calls"	self assert: 			(objClass objIVs = #(#class #name #superclass #iv #keywords #methodDict)).	self assert: 			(objClass objKeywords = #(#name: #superclass: #iv: #keywords: #methodDict:))! !Obj initialize!